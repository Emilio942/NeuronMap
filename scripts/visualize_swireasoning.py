#!/usr/bin/env python3
"""
SwiReasoning Visualization Script
=================================

Reads the trace JSON generated by benchmark_swireasoning.py and creates
plots showing entropy trends and mode switches over time.
"""

import json
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from pathlib import Path
import glob
import os
import numpy as np

def load_latest_trace():
    """Finds and loads the most recent trace JSON file."""
    files = glob.glob("outputs/benchmarks/swireasoning_traces_*.json")
    if not files:
        print("No trace files found in outputs/benchmarks/")
        return None
    
    latest_file = max(files, key=os.path.getctime)
    print(f"Loading trace from: {latest_file}")
    
    with open(latest_file, 'r') as f:
        return json.load(f)

def plot_trace(trace_data, output_dir):
    """Generates a plot for a single trace."""
    prompt = trace_data['prompt']
    category = trace_data['category']
    entropy = trace_data['entropy_history']
    blocks = trace_data['blocks']
    switches = trace_data['switches']
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 6))
    
    # Plot Entropy Line
    ax.plot(entropy, color='black', linewidth=1.5, label='Entropy')
    
    # Shade Background based on Mode
    # We iterate through blocks to shade regions
    # Latent = Blue (Thinking), Explicit = Orange (Speaking)
    
    y_min, y_max = min(entropy), max(entropy)
    y_range = y_max - y_min
    # Add some padding
    y_lim_min = max(0, y_min - 0.1 * y_range)
    y_lim_max = y_max + 0.1 * y_range
    ax.set_ylim(y_lim_min, y_lim_max)
    
    for block in blocks:
        start = block['start']
        end = block['end']
        if end is None or end == 0: 
            end = len(entropy) # Handle last block if not closed properly
        
        width = end - start
        if width <= 0: continue
        
        if block['type'] == 'latent':
            color = 'lightblue'
            alpha = 0.3
            label = 'Latent (Thinking)'
        else:
            color = 'navajowhite'
            alpha = 0.3
            label = 'Explicit (Speaking)'
            
        # Add patch
        rect = patches.Rectangle((start, y_lim_min), width, y_lim_max - y_lim_min, 
                                 linewidth=0, edgecolor='none', facecolor=color, alpha=alpha)
        ax.add_patch(rect)
        
        # Add text label for mode in the middle of the block
        if width > 2:
            ax.text(start + width/2, y_lim_max - 0.05 * y_range, block['type'].upper(), 
                    ha='center', va='top', fontsize=8, color='grey')

    # Mark Switches
    for switch in switches:
        idx = switch['token_idx']
        ax.axvline(x=idx, color='red', linestyle='--', alpha=0.5)
        # ax.text(idx, y_lim_max, "Switch", rotation=90, verticalalignment='bottom')

    # Formatting
    ax.set_title(f"SwiReasoning Trace: {category.upper()} - \"{prompt[:40]}...\"", fontsize=14)
    ax.set_xlabel("Token Index")
    ax.set_ylabel("Entropy (Nats)")
    ax.grid(True, linestyle=':', alpha=0.6)
    
    # Custom Legend (deduplicate labels)
    from matplotlib.lines import Line2D
    custom_lines = [
        Line2D([0], [0], color='black', lw=2),
        patches.Patch(facecolor='lightblue', alpha=0.3),
        patches.Patch(facecolor='navajowhite', alpha=0.3),
        Line2D([0], [0], color='red', linestyle='--', lw=1)
    ]
    ax.legend(custom_lines, ['Entropy', 'Latent Mode', 'Explicit Mode', 'Switch Point'], loc='upper right')
    
    # Save
    safe_prompt = "".join([c if c.isalnum() else "_" for c in prompt[:20]])
    filename = f"{category}_{safe_prompt}.png"
    output_path = output_dir / filename
    plt.savefig(output_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved plot to {output_path}")

def main():
    traces = load_latest_trace()
    if not traces:
        return

    output_dir = Path("outputs/plots")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"Generating plots for {len(traces)} traces...")
    
    for trace in traces:
        try:
            plot_trace(trace, output_dir)
        except Exception as e:
            print(f"Failed to plot trace for prompt '{trace.get('prompt', 'Unknown')}': {e}")

if __name__ == "__main__":
    main()
